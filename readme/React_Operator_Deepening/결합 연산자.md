### 결합 연산자

생성 연산자와 변환 연산자는 1개의 데이터 흐름을 다뤘다.

결합 연산자는 여러 개의 Observable을 조합하여 활용한다.



</br>



#### zip

zip 함수의 특징은 각각의 Observable을 모두 활용해 2개 혹은 그 이상의 Observable을 결합할 수 있다는 것이다.

예를 들어 A, B 두개의 Observable을 결합한다면 2개의 Observable에서 모두 데이터를 발행할 때까지 발행을 기다린다. </br>



<img src="https://github.com/Im-Tae/RxJava2_Study/blob/master/image/zip.png?raw=true" width = "550" height = "300"  /> </br>



**입력**

```kotlin
import common.Log
import common.Shape
import io.reactivex.Observable
import io.reactivex.functions.BiFunction

class ZipExample {
    fun marbleDiagram() {
        val shapes = arrayOf("BALL", "PENTAGON", "STAR")
        val coloredTriangles = arrayOf("2-T", "6-T", "4-T")

        val source = Observable.zip(
            Observable.fromArray(*shapes).map(Shape()::getSuffix),
            Observable.fromArray(*coloredTriangles).map(Shape()::getColor),
            BiFunction<String?, String?, String> { suffix, color -> "$color$suffix" }
        )

        source.subscribe { data -> Log.it(data) }
    }
}

fun main() {
    val demo = ZipExample()
    demo.marbleDiagram()
}
```

**출력**

```
main | value = 2
main | value = 6-P
main | value = 4-S
```



아래는 위에서 사용한 getSuffix 함수와 getColor 함수의 코드이다.</br>



**입력**

```kotlin
class Shape {

    val HEXAGON = "HEXAGON"
    val OCTAGON = "OCTAGON"
    val RECTANGLE = "RECTANGLE"
    val TRIANGLE = "TRIANGLE"
    val DIAMOND = "DIAMOND"
    val PENTAGON = "PENTAGON"
    val BALL = "BALL"
    val STAR = "STAR"

    fun getSuffix(shape: String): String {
        if (HEXAGON == shape) return "-H"
        if (OCTAGON == shape) return "-O"
        if (RECTANGLE == shape) return "-R"
        if (TRIANGLE == shape) return "-T"
        if (DIAMOND == shape) return "<>"
        if (PENTAGON == shape) return "-P"
        return if (STAR == shape) "-S" 
        else "" // 이것은 BALL
    }

    fun getColor(shape: String): String? {
        if (shape.endsWith("<>")) //diamond
            return shape.replace("<>", "").trim(' ')

        val hyphen = shape.indexOf("-")

        return if (hyphen > 0) {
            shape.substring(0, hyphen)
        } else shape
    }
}
```



getSuffix 함수는 shape에서 값을 받아온 다음, 도형의 모양 접미사를 가져온다. ( 예를 들어 STAR은 -S ) 그리고 getColor 함수는 값을 받아서 모양의 색상 값으로 변환한다. ( 예를 들어 2-T는 2 )

</br>

위에서는 2개의 Observable을 결합했지만, zip 함수는 최대 9개의 Observable을 결합할 수 있다.

하지만 보통 2개, 3개면 충분하다.</br>



아래는 zip 함수를 활용한 숫자 결합의 예제 코드이다.</br>



**입력**

```kotlin
import common.Log
import io.reactivex.Observable
import io.reactivex.functions.Function3

class ZipExample {
    fun zipNumbers() {
        val source = Observable.zip(
            Observable.just(100, 200, 300),
            Observable.just(10, 20, 30),
            Observable.just(1, 2, 3),
            Function3 { num1: Int, num2: Int, num3: Int -> num1 + num2 + num3 }
        )
        
        source.subscribe { data -> Log.it(data) }
    }
}

fun main() {
    val demo = ZipExample()
    demo.zipNumbers()
}
```

**출력**

```
main | value = 111
main | value = 222
main | value = 333
```



3개의 Observable을 결합하였다.



아래는 zip과 interval 함수를 사용한 시간 결합의 예제 코드이다.</br>



**입력**

```kotlin
import common.CommonUtils
import common.Log
import io.reactivex.Observable
import io.reactivex.functions.BiFunction
import java.util.concurrent.TimeUnit

class ZipExample {
    fun zipInterval() {
        val source = Observable.zip(
            Observable.just("RED", "GREEN", "BLUE"),
            Observable.interval(200, TimeUnit.MILLISECONDS),
            BiFunction { value: String, _: Long -> value }
        )

        CommonUtils.start()
        source.subscribe { data -> Log.it(data) }
        CommonUtils.sleep(1000)
    }
}

fun main() {
    val demo = ZipExample()
    demo.zipInterval()
}
```

**출력**

```
RxComputationThreadPool-1 | 223 | value = RED
RxComputationThreadPool-1 | 409 | value = GREEN
RxComputationThreadPool-1 | 609 | value = BLUE
```



얼핏 생각하면 같은 타입의 데이터만 결합 할 수 있을 것으로 생각되지만, 데이터뿐만 아니라 시간과도 결합하는 것을 볼 수 있다. 이를 zipInterval 기법이라고 한다. 데이터를 발행하는 시간을 조절할 수 있다.</br>



아래는 전기 요금 계산 예제 코드이다.</br>



| 기본요금(원/호)           | 전력량 요금(원/kWh)     |
| ------------------------- | ----------------------- |
| 200kWh 이하 사용 - 910    | 처음 200kWh까지 - 93.3  |
| 201 ~ 400kWh 사용 - 1,600 | 다음 200kWh까지 - 187.9 |
| 400kWh 초과 사용 - 7.300  | 400kWh 초과 - 280.6     |



</br>



**입력**

```kotlin
import common.Log
import io.reactivex.Observable
import io.reactivex.functions.BiFunction
import java.lang.Math.max
import java.lang.Math.min
import java.lang.StringBuilder
import java.text.DecimalFormat

class ZipExample {fun electricBillV1() {

        var index: Int = 0

        val data = arrayOf(
            "100",  //910 + 93.3 * 100 = 10,240원
            "300"   //1600 + 93.3 * 200 + 187.9 * 100 = 39,050원
        )

        val basePrice: Observable<Int> = Observable.fromArray(*data)
            .map { value -> Integer.parseInt(value) }
            .map { value ->
                if (value <= 200) return@map 910
                if (value <= 400) return@map 1600
                return@map 7300
            }

        val usagePrice = Observable.fromArray(*data)
            .map { value -> Integer.parseInt(value) }
            .map { value ->
                val series1 = min(200, value) * 93.3
                val series2 = min(200, max(value - 200, 0)) * 187.9
                val series3 = max(0, max(value - 400, 0)) * 280.65
                return@map (series1 + series2 + series3).toInt()
            }

        val source = Observable.zip(
            basePrice,
            usagePrice,
            BiFunction { v1: Int, v2: Int -> v1 + v2 }
        )

        source.map { value -> DecimalFormat("#,###").format(value) }
            .subscribe {value ->
                val sb = StringBuilder()
                sb.append("Usage: ${data[index]} kWh => ")
                sb.append("Price: ${value}원")
                Log.it(sb.toString())

                index++
            }
    }
}

fun main() {
    val demo = ZipExample()
    demo.electricBillV1()
}
```

**출력**

```
main | value = Usage: 100 kWh => Price: 10,240원
main | value = Usage: 300 kWh => Price: 39,050원
```



기본 요금은 basePrice Observable, 전력량 요금은 usagePrice Observable로 분리했다.

이 코드에서 중요한 점은 두 개의 요금을 계산한 것이 아닌, zip을 사용하여 결합한 것이다.

전기 요금을 출력하기 위해서는 천 원 단위로 콤마를 붙여줘야 하는데 DecimalFormat을 사용하였다.

</br>



위에 코드에는 문제점이 있다. 전력 사용량을 출력하기 위해 멤버 변수 index를 참조하여 부수효과가 생긴 것이다. </br>



> 부수효과란, 결과값 이외에 다른 상태를 변경시킬 때 **부수효과**가 있다고 말한다. 예를 들어, 함수가 전역변수나 정적변수를 수정하거나, 인자로 넘어온 것들 중 하나를 변경하거나 화면이나 파일에 데이터를 쓰거나, 다른 부수효과가 있는 함수에서 데이터를 읽어오는 경우가 있다. 부수효과는 프로그램의 동작을 이해하기 어렵게 한다.

</br>



아래는 부수효과를 없앤 전기 요금 계산 예제 코드이다.

조건은 아래와 같다.

</br>

1. data를 추가로 넘겨주는 방법
2. Pair 클래스의 사용
3. zip이 결합하는 3개의 Observable

</br>



**입력**

```kotlin
import common.Log
import io.reactivex.Observable
import io.reactivex.functions.Function3
import java.lang.Math.max
import java.lang.Math.min
import java.lang.StringBuilder
import java.text.DecimalFormat

class ZipExample {
    fun electricBillV2() {
        val data = arrayOf(
            "100",  //910 + 93.3 * 100 = 10,240원
            "300"   //1600 + 93.3 * 200 + 187.9 * 100 = 39,050원
        )

        val basePrice: Observable<Int> = Observable.fromArray(*data)
            .map { value -> Integer.parseInt(value) }
            .map { value ->
                if (value <= 200) return@map 910
                if (value <= 400) return@map 1600
                return@map 7300
            }

        val usagePrice = Observable.fromArray(*data)
            .map { value -> Integer.parseInt(value) }
            .map { value ->
                val series1 = min(200, value) * 93.3
                val series2 = min(200, max(value - 200, 0)) * 187.9
                val series3 = max(0, max(value - 400, 0)) * 280.65
                return@map (series1 + series2 + series3).toInt()
            }

        val source = Observable.zip(
            basePrice,
            usagePrice,
            Observable.fromArray(*data),
            Function3{ v1: Int, v2: Int, i: String -> Pair(i, v1 + v2) }
        )

        source.map { value -> Pair(value.first, DecimalFormat("#,###").format(value.second)) }
            .subscribe { value ->
                val sb = StringBuilder()
                sb.append("Usage: ${value.first} kWh => ")
                sb.append("Price: ${value.second}원")
                Log.it(sb.toString())
            }
    }
}

fun main() {
    val demo = ZipExample()
    demo.electricBillV2()
}
```

**출력**

```
main | value = Usage: 100 kWh => Price: 10,240원
main | value = Usage: 300 kWh => Price: 39,050원
```



zip 함수의 세 번째 인자로 원래 데이터 그대로 넣고 Pair 클래스를 호출하여 Pair 객체를 생성했다.

결과를 출력할땐 Pair 객체의 first와 second를 사용했다.

실행 결과는 같지만 위와 같은 방법으로 부수효과를 없앨 수 있다.

</br>



아래는 zipWith을 활용한 코드이다.

</br>



**입력**

```kotlin
import common.Log
import io.reactivex.Observable
import io.reactivex.functions.BiFunction

class ZipExample {
    fun zipWithNumbers() {
        val source = Observable.zip(
                Observable.just(100, 200, 300),
                Observable.just(10, 20, 30),
                BiFunction { a: Int, b: Int -> a + b })
            .zipWith(Observable.just(1, 2, 3), BiFunction { ab: Int, c: Int -> ab + c })

        source.subscribe { data -> Log.it(data) }
    }
}

fun main() {
    val demo = ZipExample()
    demo.zipWithNumbers()
}
```

**출력**

```
main | value = 111
main | value = 222
main | value = 333
```



zipNumbers 함수에서 3개의 Observable을 결합했지만, 위에 코드는 2 개의 Observable을 zip으로 묶고 세 번째 Observable을 zipWith으로 결합했다.

실행 결과는 같다.

</br></br>